<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Download de NFE</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .table-responsive {
            margin-top: 20px;
        }
        .status-cell {
            min-width: 200px;
        }
        .key-cell {
            font-family: monospace;
        }
        .loading {
            display: inline-block;
            margin-right: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        .url-button {
            display: none;
        }
        .cached {
            color: #0d6efd;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .progress {
            height: 20px;
            margin-bottom: 10px;
        }
        .batch-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #downloadProgress {
            flex-grow: 1;
        }
        .status-message {
            margin-top: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4">Sistema de Download de NFE</h1>

        <div class="card">
            <div class="card-body">
                <div class="batch-controls">
                    <button class="btn btn-primary" onclick="downloadAll()" id="downloadAllBtn">
                        <i class="fas fa-download"></i> Baixar Todos os XMLs
                    </button>
                    <button class="btn btn-success" onclick="openAllUrls()" id="openAllUrlsBtn">
                        <i class="fas fa-external-link-alt"></i> Abrir Todas as URLs
                    </button>
                    <button class="btn btn-warning" onclick="clearCache()" id="clearCacheBtn">
                        <i class="fas fa-trash"></i> Limpar Cache
                    </button>
                    <div class="progress" id="downloadProgress" style="display: none;">
                        <div class="progress-bar" role="progressbar" style="width: 0%;" 
                             aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    <button class="btn btn-danger" onclick="cancelDownloads()" id="cancelBtn" style="display: none;">
                        <i class="fas fa-stop"></i> Cancelar
                    </button>
                </div>

                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Chave NFE</th>
                                <th>Status</th>
                                <th>Ações</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for key in keys %}
                            <tr>
                                <td class="key-cell">{{ key }}</td>
                                <td class="status-cell" id="status-{{ key }}">
                                    {% if key in cache %}
                                    <span class="text-success">
                                        <i class="fas fa-check"></i> Download disponível
                                        <span class="cached"><i class="fas fa-clock"></i> Em cache</span>
                                    </span>
                                    {% else %}
                                    <span class="text-muted">Aguardando processamento</span>
                                    {% endif %}
                                </td>
                                <td>
                                    <div class="action-buttons">
                                        <button class="btn btn-primary btn-sm download-btn" 
                                                onclick="processNFE('{{ key }}')"
                                                id="btn-{{ key }}">
                                            <i class="fas fa-download"></i> Baixar XML
                                        </button>
                                        <a href="{% if key in cache %}{{ cache[key]['url'] }}{% else %}#{% endif %}" 
                                           class="btn btn-success btn-sm url-button" 
                                           id="url-btn-{{ key }}" 
                                           target="_blank"
                                           style="display: {% if key in cache %}inline-block{% else %}none{% endif %}">
                                            <i class="fas fa-external-link-alt"></i> Abrir URL
                                        </a>
                                    </div>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Cache local
        const urlCache = new Map();
        let isDownloading = false;
        let shouldCancelDownloads = false;

        // Inicializa o cache com dados do servidor
        {% for key, data in cache.items() %}
        urlCache.set('{{ key }}', '{{ data.url }}');
        {% endfor %}

        function updateGlobalStatus(message, type = 'success') {
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            const statusSpan = document.createElement('span');
            statusSpan.className = `status-message text-${type}`;
            statusSpan.innerHTML = message;
            
            // Remove mensagem anterior se existir
            const oldStatus = downloadAllBtn.parentElement.querySelector('.status-message');
            if (oldStatus) {
                oldStatus.remove();
            }
            
            // Adiciona nova mensagem após o botão
            downloadAllBtn.parentElement.appendChild(statusSpan);
            
            // Remove a mensagem após 5 segundos
            setTimeout(() => statusSpan.remove(), 5000);
        }

        function updateStatus(key, message, isError = false, isCached = false) {
            const statusCell = document.getElementById(`status-${key}`);
            let statusHtml = `<span class="text-${isError ? 'danger' : 'success'}">${message}`;
            if (isCached) {
                statusHtml += `<span class="cached"><i class="fas fa-clock"></i> Em cache</span>`;
            }
            statusHtml += '</span>';
            statusCell.innerHTML = statusHtml;
        }

        function showUrlButton(key, url) {
            const urlButton = document.getElementById(`url-btn-${key}`);
            urlButton.href = url;
            urlButton.style.display = 'inline-block';
            
            // Atualiza o cache local
            urlCache.set(key, url);

            // Simula o clique no botão automaticamente
            window.open(url, '_blank');
        }

        function updateProgress(current, total) {
            const progress = document.querySelector('#downloadProgress .progress-bar');
            const percentage = Math.round((current / total) * 100);
            progress.style.width = `${percentage}%`;
            progress.setAttribute('aria-valuenow', percentage);
            progress.textContent = `${percentage}% (${current}/${total})`;
        }

        async function processNFEAsync(key) {
            const button = document.getElementById(`btn-${key}`);
            const urlButton = document.getElementById(`url-btn-${key}`);
            button.disabled = true;
            
            try {
                // Se já temos no cache, use diretamente
                if (urlCache.has(key)) {
                    const cachedUrl = urlCache.get(key);
                    updateStatus(key, '<i class="fas fa-check"></i> Download disponível', false, true);
                    showUrlButton(key, cachedUrl);
                    await fetch(`/download/${key}`);
                    button.disabled = false;
                    return true;
                }

                urlButton.style.display = 'none';
                updateStatus(key, '<i class="fas fa-spinner fa-spin"></i> Obtendo URL...', false);

                const response = await fetch(`/get-url/${key}`);
                const data = await response.json();

                if (data.success) {
                    updateStatus(key, '<i class="fas fa-check"></i> Download disponível', false, data.from_cache);
                    showUrlButton(key, data.url);
                    await fetch(`/download/${key}`);
                    button.disabled = false;
                    return true;
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                updateStatus(key, `<i class="fas fa-exclamation-triangle"></i> ${error.message}`, true);
                button.disabled = false;
                urlButton.style.display = 'none';
                updateGlobalStatus(`Erro ao processar NFE ${key}: ${error.message}`, 'danger');
                return false;
            }
        }

        function processNFE(key) {
            processNFEAsync(key).then(success => {
                if (success) {
                    window.location.href = `/download/${key}`;
                }
            });
        }

        async function downloadAll(retryAttempt = 0, keysToProcess = null) {
            if (isDownloading) return;
            
            // Se não foram fornecidas chaves específicas, processa todas as pendentes
            const pendingKeys = keysToProcess || Array.from(document.querySelectorAll('.key-cell'))
                .filter(td => {
                    const key = td.textContent.trim();
                    const urlButton = document.getElementById(`url-btn-${key}`);
                    return urlButton.style.display === 'none';
                })
                .map(td => td.textContent.trim());

            if (pendingKeys.length === 0) {
                updateGlobalStatus('Não há chaves pendentes para processar', 'info');
                return;
            }

            const totalKeys = pendingKeys.length;
            let successCount = 0;
            let failCount = 0;
            let processedCount = 0;
            
            // Armazena as chaves que falharam para possível novo processamento
            let failedKeys = [];

            isDownloading = true;
            shouldCancelDownloads = false;
            
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            downloadAllBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Processando...';
            
            document.getElementById('downloadProgress').style.display = 'flex';
            document.getElementById('cancelBtn').style.display = 'inline-block';
            downloadAllBtn.disabled = true;

            while (processedCount < totalKeys && !shouldCancelDownloads) {
                const batch = pendingKeys.slice(processedCount, processedCount + 10);
                
                try {
                    const results = await Promise.all(
                        batch.map(async (key) => {
                            const success = await processNFEAsync(key);
                            if (!success) {
                                failedKeys.push(key);
                            }
                            return success;
                        })
                    );
                    
                    results.forEach(success => {
                        if (success) successCount++;
                        else failCount++;
                    });

                    processedCount += batch.length;
                    updateProgress(processedCount, totalKeys);

                } catch (error) {
                    console.error('Erro no processamento do lote:', error);
                }

                if (shouldCancelDownloads) {
                    updateGlobalStatus('Processamento cancelado pelo usuário', 'warning');
                    break;
                }
            }

            // Verifica se devemos fazer nova tentativa com as chaves que falharam
            if (failedKeys.length > 0 && !shouldCancelDownloads && retryAttempt < 3) {
                isDownloading = false;
                document.getElementById('downloadProgress').style.display = 'none';
                document.getElementById('cancelBtn').style.display = 'none';
                
                // Mensagem temporária sobre o reprocessamento
                updateGlobalStatus(`Reprocessando ${failedKeys.length} chave(s) com erro. Tentativa ${retryAttempt + 1}/3...`, 'warning');
                
                // Aguarda 2 segundos antes de iniciar novo processamento
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Inicia nova tentativa com as chaves que falharam
                return downloadAll(retryAttempt + 1, failedKeys);
            }

            isDownloading = false;
            document.getElementById('downloadProgress').style.display = 'none';
            document.getElementById('cancelBtn').style.display = 'none';
            downloadAllBtn.disabled = false;
            downloadAllBtn.innerHTML = '<i class="fas fa-download"></i> Baixar Todos os XMLs';

            const remainingCount = document.querySelectorAll('.url-button[style="display: none;"]').length;
            let message = `Processamento concluído: ${successCount} sucesso(s), ${failCount} falha(s)`;
            
            if (failedKeys.length > 0 && retryAttempt >= 3) {
                message += `. Máximo de tentativas atingido. ${failedKeys.length} chave(s) ainda com erro.`;
            } else if (remainingCount > 0) {
                message += `. Ainda restam ${remainingCount} chave(s) pendente(s).`;
            }
            
            updateGlobalStatus(
                message,
                remainingCount === 0 ? 'success' : 'warning'
            );
        }

        function cancelDownloads() {
            shouldCancelDownloads = true;
            document.getElementById('cancelBtn').disabled = true;
        }

        function openAllUrls() {
            const urlButtons = Array.from(document.querySelectorAll('.url-button'))
                .filter(btn => btn.style.display !== 'none');

            if (urlButtons.length === 0) {
                updateGlobalStatus('Não há URLs disponíveis para abrir', 'warning');
                return;
            }

            urlButtons.forEach(btn => {
                if (btn.href && btn.href !== '#') {
                    window.open(btn.href, '_blank');
                }
            });

            updateGlobalStatus(`${urlButtons.length} URL(s) abertas em novas abas`, 'success');
        }

        async function clearCache() {
            if (!confirm('Tem certeza que deseja limpar o cache? Todas as URLs salvas serão perdidas.')) {
                return;
            }

            try {
                const response = await fetch('/clear-cache', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    urlCache.clear();

                    document.querySelectorAll('.url-button').forEach(btn => {
                        btn.style.display = 'none';
                        btn.href = '#';
                    });

                    document.querySelectorAll('.status-cell').forEach(cell => {
                        cell.innerHTML = '<span class="text-muted">Aguardando processamento</span>';
                    });

                    updateGlobalStatus('Cache limpo com sucesso', 'success');
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                updateGlobalStatus(`Erro ao limpar cache: ${error.message}`, 'danger');
            }
        }
    </script>
</body>
</html> 